<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prompt Chaining Workflow Explanation</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
      }
      h1,
      h2,
      h3 {
        color: #2c3e50;
      }
      .workflow-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin: 30px 0;
      }
      .workflow-step {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        background-color: #f9f9f9;
      }
      .workflow-step h3 {
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
      }
      .code-block {
        background-color: #f5f5f5;
        border-left: 4px solid #2c3e50;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        overflow-x: auto;
      }
      .flow-diagram {
        margin: 30px 0;
        text-align: center;
      }
      .arrow {
        text-align: center;
        font-size: 24px;
        margin: 10px 0;
      }
      .highlight {
        background-color: #ffffcc;
        padding: 2px 4px;
      }
    </style>
  </head>
  <body>
    <h1>Prompt Chaining Workflow Explanation</h1>

    <p>
      This document explains the prompt chaining workflow implemented in
      <code>prompt_chaining.py</code>. Prompt chaining is a technique where
      multiple AI model calls are sequenced together, with each call building
      upon the results of previous calls.
    </p>

    <h2>Overview</h2>
    <p>
      The workflow demonstrates a three-step prompt chaining process for
      handling calendar event requests:
    </p>
    <ol>
      <li>
        <strong>Event Extraction</strong>: Determines if a user's input
        describes a calendar event
      </li>
      <li>
        <strong>Event Details Extraction</strong>: Extracts specific details
        from confirmed calendar events
      </li>
      <li>
        <strong>Confirmation Generation</strong>: Creates a natural language
        confirmation message
      </li>
    </ol>

    <div class="flow-diagram">
      <div class="workflow-step">
        <h3>User Input</h3>
        <p>"I have a meeting with John tomorrow at 10am for 2 hours"</p>
      </div>
      <div class="arrow">↓</div>
      <div class="workflow-step">
        <h3>Step 1: Event Extraction</h3>
        <p>
          Determines if the text describes a calendar event and provides a
          confidence score
        </p>
        <p>Output: <code>EventExtraction</code> object</p>
      </div>
      <div class="arrow">↓</div>
      <div class="workflow-step">
        <h3>Step 2: Event Details Extraction</h3>
        <p>
          Extracts specific details like name, date, duration, and participants
        </p>
        <p>Output: <code>EventDetails</code> object</p>
      </div>
      <div class="arrow">↓</div>
      <div class="workflow-step">
        <h3>Step 3: Confirmation Generation</h3>
        <p>Creates a natural language confirmation message</p>
        <p>Output: <code>EventConfirmation</code> object</p>
      </div>
    </div>

    <h2>Implementation Details</h2>

    <h3>Data Models</h3>
    <p>The workflow uses Pydantic models to structure the data at each step:</p>
    <div class="code-block">
      <pre>
class EventExtraction(BaseModel):
    description: str
    is_calendar_event: bool
    confidence_score: float

class EventDetails(BaseModel):
    name: str
    date: str
    duration_minutes: int
    participants: list[str]

class EventConfirmation(BaseModel):
    confirmation_message: str
        </pre
      >
    </div>

    <h3>Step 1: Event Extraction</h3>
    <p>
      The <code>extract_event_info()</code> function takes user input and
      determines if it describes a calendar event. It uses the Gemini 2.0 Pro
      model to analyze the text and returns an
      <code>EventExtraction</code> object.
    </p>
    <p>Key features:</p>
    <ul>
      <li>Provides the current date for context</li>
      <li>Returns a confidence score to enable gatekeeping</li>
      <li>Extracts a description for further processing</li>
    </ul>

    <h3>Step 2: Event Details Extraction</h3>
    <p>
      If the first step confirms a calendar event with sufficient confidence,
      the <code>extract_event_details()</code> function processes the
      description to extract specific details like name, date, duration, and
      participants.
    </p>
    <p>Key features:</p>
    <ul>
      <li>Provides date context for resolving relative time references</li>
      <li>
        Structures the output in a standardized format (ISO 8601 for dates)
      </li>
      <li>Identifies all participants involved</li>
    </ul>

    <h3>Step 3: Confirmation Generation</h3>
    <p>
      The final step uses the
      <code>generate_confirmation_message()</code> function to create a natural
      language confirmation based on the extracted event details.
    </p>
    <p>Key features:</p>
    <ul>
      <li>Uses an example to guide the model's output format</li>
      <li>Personalizes the message with a signature</li>
      <li>Maintains a conversational tone</li>
    </ul>

    <h3>Orchestration</h3>
    <p>
      The <code>process_event_request()</code> function orchestrates the entire
      workflow:
    </p>
    <div class="code-block">
      <pre>
def process_event_request(text: str) -> Optional[EventConfirmation]:
    event_check = extract_event_info(text)
    
    # Gatekeeping: Only proceed if it's a calendar event with high confidence
    if (not event_check.is_calendar_event or event_check.confidence_score < 0.7):
        return None
    
    event_details = extract_event_details(event_check.description)
    confirmation = generate_confirmation_message(event_details)
    
    return confirmation
        </pre
      >
    </div>

    <h2>Benefits of Prompt Chaining</h2>
    <p>This workflow demonstrates several benefits of prompt chaining:</p>
    <ul>
      <li>
        <strong>Specialized Tasks</strong>: Each step focuses on a specific
        task, improving accuracy
      </li>
      <li>
        <strong>Gatekeeping</strong>: Early steps can filter out inappropriate
        inputs
      </li>
      <li>
        <strong>Structured Data</strong>: Each step produces well-defined
        outputs for the next step
      </li>
      <li>
        <strong>Progressive Refinement</strong>: Information is gradually
        refined through the chain
      </li>
      <li>
        <strong>Error Handling</strong>: The chain can be interrupted if any
        step fails
      </li>
    </ul>

    <h2>Example Usage</h2>
    <p>The code demonstrates the workflow with two examples:</p>
    <div class="code-block">
      <pre>
# Example 1: Appropriate calendar event
appropriate_user_input = "I have a meeting with John tomorrow at 10am for 2 hours"
confirmation = process_event_request(appropriate_user_input)
# Result: Returns a confirmation message

# Example 2: Inappropriate input
unappropriate_user_input = "Can you tell me about the weather in Tokyo?"
unappropriate_confirmation = process_event_request(unappropriate_user_input)
# Result: Returns None (gatekeeping prevents processing)
        </pre
      >
    </div>

    <h2>Conclusion</h2>
    <p>
      Prompt chaining is a powerful technique for building complex AI workflows.
      By breaking down tasks into smaller, specialized steps, we can create more
      robust and accurate systems. This example demonstrates how to implement
      prompt chaining for calendar event processing using the Gemini 2.0 Pro
      model.
    </p>
  </body>
</html>
