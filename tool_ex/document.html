<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini API Function Calling Example</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
      }
      h1,
      h2,
      h3 {
        color: #1a73e8;
      }
      pre {
        background-color: #f5f5f5;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
      }
      code {
        font-family: "Courier New", Courier, monospace;
        background-color: #f5f5f5;
        padding: 2px 4px;
        border-radius: 3px;
      }
      .note {
        background-color: #e7f3fe;
        border-left: 6px solid #2196f3;
        padding: 10px;
        margin: 15px 0;
      }
      .warning {
        background-color: #fff3cd;
        border-left: 6px solid #ffc107;
        padding: 10px;
        margin: 15px 0;
      }
      .section {
        margin-bottom: 30px;
      }
      .flow-diagram {
        margin: 20px 0;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>Understanding the Gemini API Function Calling Example</h1>

    <div class="section">
      <h2>Overview</h2>
      <p>
        This document explains the <code>tool_ex_weather.py</code> script, which
        demonstrates how to use the Google Gemini API's function calling
        capability. The script allows the Gemini model to request weather
        information for a location and then respond with a natural language
        summary of that weather data.
      </p>
    </div>

    <div class="section">
      <h2>What is Function Calling?</h2>
      <p>
        Function calling is a feature of the Gemini API that allows the AI model
        to:
      </p>
      <ol>
        <li>Recognize when it needs external data to answer a query</li>
        <li>Request that data by "calling" a function you've defined</li>
        <li>Receive the results of that function</li>
        <li>Incorporate the results into its response</li>
      </ol>
      <p>
        In this example, when asked about the weather in Istanbul, the model
        recognizes it needs current weather data and calls the
        <code>get_weather</code> function with the appropriate coordinates.
      </p>
    </div>

    <div class="section">
      <h2>Script Structure</h2>
      <p>The script is organized into several key sections:</p>
      <ol>
        <li>Imports and setup</li>
        <li>The <code>get_weather</code> function implementation</li>
        <li>Function declaration for the Gemini API</li>
        <li>Initial API call with function calling configuration</li>
        <li>Processing the response and handling the function call</li>
        <li>Sending the function results back to the model</li>
      </ol>
    </div>

    <div class="section">
      <h2>Flow Diagram</h2>
      <div class="flow-diagram">
        <pre>
User Query → Gemini API → Function Call Request → Execute Function 
                                                        ↓
User Response ← Gemini API ← Function Response ← Weather Data
            </pre
        >
      </div>
    </div>

    <div class="section">
      <h2>Key Components Explained</h2>

      <h3>1. The Weather Function</h3>
      <p>
        The <code>get_weather</code> function retrieves weather data from the
        Open-Meteo API for a given latitude and longitude:
      </p>
      <pre>
def get_weather(latitude: float, longitude: float) -> dict:
    """
    Retrieves today's temperature data from the Open-Meteo API for the specified coordinates.
    """
    # Function implementation...
    # Returns a dictionary with date, max_temperature, and min_temperature
</pre
      >

      <h3>2. Function Declaration</h3>
      <p>
        We define a <code>FunctionDeclaration</code> that tells the Gemini API
        about our function:
      </p>
      <pre>
weather_function_declaration = types.FunctionDeclaration(
    name="get_weather",
    description="Retrieves today's temperature data for the specified coordinates",
    parameters={
        "type": "object",
        "properties": {
            "latitude": {
                "type": "number",
                "description": "The latitude of the location"
            },
            "longitude": {
                "type": "number",
                "description": "The longitude of the location"
            }
        },
        "required": ["latitude", "longitude"]
    }
)</pre
      >
      <p>This declaration specifies:</p>
      <ul>
        <li>The function name</li>
        <li>A description of what the function does</li>
        <li>The parameters it accepts (latitude and longitude)</li>
        <li>Which parameters are required</li>
      </ul>

      <h3>3. API Configuration</h3>
      <p>
        We configure the Gemini API call with the function declaration and
        function calling settings:
      </p>
      <pre>
response = client.models.generate_content(
    contents=["What is the weather in Istanbul?"],
    model="gemini-2.0-flash",
    config=types.GenerateContentConfig(
        tools=[types.Tool(
            function_declarations=[weather_function_declaration]
        )],
        tool_config=types.ToolConfig(
            function_calling_config=types.FunctionCallingConfig(
                mode="any",
                allowed_function_names=["get_weather"]
            )
        ),
        automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=False)
    )
)</pre
      >

      <div class="note">
        <strong>Note:</strong> In the latest Gemini API, the
        <code>function_calling_config</code> should be placed in
        <code>tool_config</code> instead of directly in the
        <code>Tool</code> object.
      </div>

      <h3>4. Handling the Response</h3>
      <p>
        We check if the response contains a function call and process it
        accordingly:
      </p>
      <pre>
if hasattr(response.candidates[0].content.parts[0], 'function_call'):
    function_call = response.candidates[0].content.parts[0].function_call
    function_name = function_call.name
    function_args = function_call.args
    
    # Execute the function with the provided arguments
    # ...
</pre
      >

      <h3>5. Sending Function Results Back</h3>
      <p>
        After executing the function, we send the results back to the model:
      </p>
      <pre>
follow_up = client.models.generate_content(
    model="gemini-2.0-flash",
    contents=[
        types.Content(
            parts=[types.Part(text="What is the weather in Istanbul?")],
            role="user"
        ),
        types.Content(
            parts=[types.Part(function_call=function_call)],
            role="model"
        ),
        types.Content(
            parts=[types.Part(function_response=types.FunctionResponse(
                name=function_name,
                response=weather_data
            ))],
            role="function"
        )
    ]
)</pre
      >
      <p>This creates a conversation history with:</p>
      <ol>
        <li>The original user query</li>
        <li>The model's function call</li>
        <li>The function's response with the weather data</li>
      </ol>
    </div>

    <div class="section">
      <h2>Common Issues and Solutions</h2>

      <div class="warning">
        <strong>Issue:</strong> Incorrect Tool Configuration
        <p>
          The most common issue is incorrectly structuring the Tool
          configuration. In the latest Gemini API, the
          <code>function_calling_config</code> should be placed in
          <code>tool_config</code> instead of directly in the
          <code>Tool</code> object.
        </p>
      </div>

      <div class="warning">
        <strong>Issue:</strong> Response Format Errors
        <p>
          When sending function results back to the model, you must use the
          proper types from the Gemini API:
          <code>types.Content</code> and <code>types.Part</code> classes to
          structure the conversation history correctly.
        </p>
      </div>
    </div>

    <div class="section">
      <h2>Sample Output</h2>
      <p>When running the script, you should see output similar to:</p>
      <pre>
Response received from Gemini API
Weather data: {'date': '2025-02-25', 'max_temperature': 6.9, 'min_temperature': 0.8}
Final response: The weather in Istanbul on 2025-02-25 will have a maximum temperature of 6.9 degrees Celsius and a minimum temperature of 0.8 degrees Celsius.
</pre
      >
    </div>

    <div class="section">
      <h2>Conclusion</h2>
      <p>
        This example demonstrates how to use the Gemini API's function calling
        capability to enhance AI responses with real-time data. By following
        this pattern, you can create applications that combine the natural
        language capabilities of Gemini with external data sources and APIs.
      </p>
    </div>

    <footer>
      <p>
        <small
          >Created based on the Google Gemini API documentation and example
          code.</small
        >
      </p>
    </footer>
  </body>
</html>
